# 实践任务4

## 第一节 数据库基本知识

### 1

#### a   1. 写出此查询的关系代数表达式及SQL语句，并记录查询结果：查询选上了2009年春季学期前所有课程的学生的学号和姓名。

#### solution

所有表的定义如下：

```sql
create table department
(dept_name varchar (20),
building varchar (15),
budget numeric (12,2),
primary key (dept_name));

create table course
(course_id varchar (7),
title varchar (50),
dept_name varchar (20),
credits numeric (2,0),
primary key (course_id),
foreign key (dept_name) references department(dept_name)
);

create table instructor
(ID varchar (5),
instructor_name varchar (20) not null,
dept_name varchar (20),
salary numeric (8,2),
primary key (ID),
foreign key (dept_name) references department(dept_name) );

create table section
(course_id varchar (8),
sec_id varchar (8),
semester varchar (6),
section_year numeric (4,0),
building varchar (15),
room_number varchar (7),
time_slot_id varchar (4),
primary key (course_id, sec_id, semester, section_year),
foreign key (course_id) references course(course_id));

create table teaches
(ID varchar (5),
course_id varchar (8),
sec_id varchar (8),
semester varchar (6),
teaches_year numeric (4,0),
primary key (ID, course_id, sec_id, semester, teaches_year),
foreign key (course_id, sec_id, semester, teaches_year) references section(course_id,sec_id,semester,section_year),
foreign key (ID) references instructor(ID));

create table classroom
(building varchar (15),
room_number varchar (7),
capacity numeric (4,0),
primary key (building, room_number));

create table student
(ID varchar (5),
student_name varchar (20) not null,
dept_name varchar (20),
tot_cred numeric (3,0) check (tot_cred >= 0),
primary key (ID),
foreign key (dept_name) references department(dept_name)
on delete set null);

create table takes
(ID varchar (5),
course_id varchar (8),
sec_id varchar (8),
semester varchar (6),
takes_year numeric (4,0),
grade varchar (2),
primary key (ID, course_id, sec_id, semester, takes_year),
foreign key (course_id, sec_id, semester, takes_year) references section(course_id,sec_id,semester,section_year)
on delete cascade,
foreign key (ID) references student(ID)
on delete cascade);

create table advisor
(s_ID varchar (5),
i_ID varchar (5),
primary key (s_ID),
foreign key (i_ID) references instructor (ID)
on delete set null,
foreign key (s_ID) references student (ID)
on delete cascade);

create table prereq
(
    course_id varchar(8),
    prereq_id varchar(8),
    primary key (course_id, prereq_id),
    foreign key (course_id) references course(course_id)
        on delete cascade,
    foreign key (prereq_id) references course(course_id)
);

create table time_slot
(time_slot_id varchar (4),
timeslot_day varchar (1) check (timeslot_day in ('M','T', 'W', 'R', 'F', 'S', 'U')),
start_time_h numeric,
start_time_m numeric,
end_time_h numeric,
end_time_m numeric,
primary key (time_slot_id, timeslot_day, start_time_h,start_time_m,end_time_h,end_time_m));


```

2009年春季学期前的所有课程id关系代数表达式如下：
$$
\pi_{course\_id}(\sigma_{takes\_year<2009}(takes))
$$

选了所有课程的学生id关系代数表达式如下：

$$
\pi_{student.ID,student.student\_name}(student - (\sigma_{student.ID}(((\pi_{course\_id}(\sigma_{takes\_year<2009}(takes)))\times (\pi_{ID}(\sigma_{takes\_year<2009}(takes))))-(\pi_{course\_id}(\sigma_{takes\_year<2009}(takes))\bowtie(\pi_{ID}(\sigma_{takes\_year<2009}(takes))))\bowtie (student))))
$$

sql语句

```sql
SELECT student.ID, student.student_name
FROM student
WHERE NOT EXISTS(
    SELECT course_id
    FROM takes
    WHERE takes_year<2009
    AND ID = student.ID
    AND NOT EXISTS(
        SELECT *
        FROM takes
        WHERE takes.takes_year<2009
        AND takes.course_id != course_id
        )
    );
```

#### b

```sql
SELECT student.ID, student.student_name, COALESCE(SUM(course.credits), 0) AS tot_cred
FROM student
LEFT JOIN (
    SELECT ID, course_id, MAX(takes_year) AS max_year, MAX(takes.semester) AS max_semester
    FROM takes
    GROUP BY ID, course_id
) AS latest_takes
ON student.ID = latest_takes.ID
JOIN course ON latest_takes.course_id = course.course_id
GROUP BY student.ID, student.student_name;
```

### 2. 设计范式
 #### 1. 设R为⼀个关系模式, α包含于R 且 β包含于R, α→β在R上成立当且仅当对于任意的关系r(R), 若r中元组t1和t2 of 的α属性相同, 则他们的β属性相同。 那么α→β是( ). 
    A、函数依赖 (FD) 
    B、多值依赖 (MVD)

#### solution

函数依赖是指在关系模式R中，对于R的任意两个元组t1和t2，如果t1[X]=t2[X]，则t1[Y]=t2[Y]，则称X函数决定Y，记为X→Y。其中X和Y是R的属性集合，X称为决定因素，Y称为被决定因素。

多值依赖是指在关系模式R中，对于R的任意两个元组t1和t2，如果t1[X]=t2[X]，则t1[Y]和t2[Y]是关系模式S的两个不同元组，其中X和Y是R的属性集合，X称为决定因素，Y称为被决定因素。

 #### 2. 考虑关系模式R(A,B,C)。若R中的依赖仅有BC→A和A→C，其余所有依赖都服从这两个依赖，那么这个模式符合什么范式？ 
    A、3NF
    B、BCNF
    C、4NF
    D、以上都不是

#### solution

BCNF

3NF: 每个非主属性都不传递依赖于候选键
BCNF: 每个非主属性都不传递依赖于候选键，且每个候选键都包含在某个候选键的超键中
4NF: 每个非主属性都不传递依赖于候选键，且每个候选键都包含在某个候选键的超键中，且不存在多值依赖


### 3 

了解Redis和MongoDB这两个数据库，并对比与MySQL的区别。该部分将通过线下答辩的形式考察，请认真准备。

#### solution

Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。

MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。

Redis和MongoDB都是非关系型数据库，而MySQL是关系型数据库。

Redis和MongoDB都是基于内存的数据库，而MySQL是基于磁盘的数据库。

Redis和MongoDB都是NoSQL数据库，而MySQL是SQL数据库。

### 3 

#### solution 

```sql
SELECT s.emp_no, m.emp_no AS manager_no, s.salary AS emp_salary, m.salary AS manager_salary
FROM dept_emp AS de
JOIN salaries AS s ON de.emp_no = s.emp_no
JOIN dept_manager AS dm ON de.dept_no = dm.dept_no
JOIN salaries AS m ON dm.emp_no = m.emp_no
WHERE s.salary > m.salary;
```